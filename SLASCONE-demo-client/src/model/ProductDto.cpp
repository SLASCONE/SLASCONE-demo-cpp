/**
 * SLASCONE API
 * Please visit our official [Documentation](https://support.slascone.com/hc/en-us/sections/360004685737-API) and/or our [GitHub repository](https://github.com/slascone/) and/or our [NuGet package](https://www.nuget.org/packages/Slascone.Client/). Always use Version 2 of this API (Version 1.3 is deprecated).
 *
 * The version of the OpenAPI document: v2
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.11.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "SlasconeOpenApiClient/model/ProductDto.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {



ProductDto::ProductDto()
{
    m_Id = utility::conversions::to_string_t("");
    m_IdIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_Description = utility::conversions::to_string_t("");
    m_DescriptionIsSet = false;
    m_Short_description = utility::conversions::to_string_t("");
    m_Short_descriptionIsSet = false;
    m_Minimum_software_release_id = utility::conversions::to_string_t("");
    m_Minimum_software_release_idIsSet = false;
    m_Software_releaseIsSet = false;
    m_Is_goodwill_visible = false;
    m_Is_goodwill_visibleIsSet = false;
    m_Is_upgrade_compliance_visible = false;
    m_Is_upgrade_compliance_visibleIsSet = false;
    m_Is_group_compliance_visible = false;
    m_Is_group_compliance_visibleIsSet = false;
    m_Is_temporary_license_rules_visible = false;
    m_Is_temporary_license_rules_visibleIsSet = false;
    m_Prioritized_keyIsSet = false;
    m_Offline_licensingIsSet = false;
    m_License_file_name = utility::conversions::to_string_t("");
    m_License_file_nameIsSet = false;
    m_User_id_typeIsSet = false;
    m_Client_id_modeIsSet = false;
    m_Maximum_inactive_days = 0;
    m_Maximum_inactive_daysIsSet = false;
    m_Max_licenses_per_user = 0;
    m_Max_licenses_per_userIsSet = false;
    m_Created_date_utc = utility::datetime();
    m_Created_date_utcIsSet = false;
    m_Modified_date_utc = utility::datetime();
    m_Modified_date_utcIsSet = false;
    m_Last_modified_by = utility::conversions::to_string_t("");
    m_Last_modified_byIsSet = false;
    m_Minimum_software_releaseIsSet = false;
    m_LogoIsSet = false;
}

ProductDto::~ProductDto()
{
}

void ProductDto::validate()
{
    // TODO: implement validation
}

web::json::value ProductDto::toJson() const
{

    web::json::value val = web::json::value::object();
    
    if(m_IdIsSet)
    {
        val[utility::conversions::to_string_t(U("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_NameIsSet)
    {
        val[utility::conversions::to_string_t(U("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_DescriptionIsSet)
    {
        val[utility::conversions::to_string_t(U("description"))] = ModelBase::toJson(m_Description);
    }
    if(m_Short_descriptionIsSet)
    {
        val[utility::conversions::to_string_t(U("short_description"))] = ModelBase::toJson(m_Short_description);
    }
    if(m_Minimum_software_release_idIsSet)
    {
        val[utility::conversions::to_string_t(U("minimum_software_release_id"))] = ModelBase::toJson(m_Minimum_software_release_id);
    }
    if(m_Software_releaseIsSet)
    {
        val[utility::conversions::to_string_t(U("software_release"))] = ModelBase::toJson(m_Software_release);
    }
    if(m_Is_goodwill_visibleIsSet)
    {
        val[utility::conversions::to_string_t(U("is_goodwill_visible"))] = ModelBase::toJson(m_Is_goodwill_visible);
    }
    if(m_Is_upgrade_compliance_visibleIsSet)
    {
        val[utility::conversions::to_string_t(U("is_upgrade_compliance_visible"))] = ModelBase::toJson(m_Is_upgrade_compliance_visible);
    }
    if(m_Is_group_compliance_visibleIsSet)
    {
        val[utility::conversions::to_string_t(U("is_group_compliance_visible"))] = ModelBase::toJson(m_Is_group_compliance_visible);
    }
    if(m_Is_temporary_license_rules_visibleIsSet)
    {
        val[utility::conversions::to_string_t(U("is_temporary_license_rules_visible"))] = ModelBase::toJson(m_Is_temporary_license_rules_visible);
    }
    if(m_Prioritized_keyIsSet)
    {
        val[utility::conversions::to_string_t(U("prioritized_key"))] = ModelBase::toJson(m_Prioritized_key);
    }
    if(m_Offline_licensingIsSet)
    {
        val[utility::conversions::to_string_t(U("offline_licensing"))] = ModelBase::toJson(m_Offline_licensing);
    }
    if(m_License_file_nameIsSet)
    {
        val[utility::conversions::to_string_t(U("license_file_name"))] = ModelBase::toJson(m_License_file_name);
    }
    if(m_User_id_typeIsSet)
    {
        val[utility::conversions::to_string_t(U("user_id_type"))] = ModelBase::toJson(m_User_id_type);
    }
    if(m_Client_id_modeIsSet)
    {
        val[utility::conversions::to_string_t(U("client_id_mode"))] = ModelBase::toJson(m_Client_id_mode);
    }
    if(m_Maximum_inactive_daysIsSet)
    {
        val[utility::conversions::to_string_t(U("maximum_inactive_days"))] = ModelBase::toJson(m_Maximum_inactive_days);
    }
    if(m_Max_licenses_per_userIsSet)
    {
        val[utility::conversions::to_string_t(U("max_licenses_per_user"))] = ModelBase::toJson(m_Max_licenses_per_user);
    }
    if(m_Created_date_utcIsSet)
    {
        val[utility::conversions::to_string_t(U("created_date_utc"))] = ModelBase::toJson(m_Created_date_utc);
    }
    if(m_Modified_date_utcIsSet)
    {
        val[utility::conversions::to_string_t(U("modified_date_utc"))] = ModelBase::toJson(m_Modified_date_utc);
    }
    if(m_Last_modified_byIsSet)
    {
        val[utility::conversions::to_string_t(U("last_modified_by"))] = ModelBase::toJson(m_Last_modified_by);
    }
    if(m_Minimum_software_releaseIsSet)
    {
        val[utility::conversions::to_string_t(U("minimum_software_release"))] = ModelBase::toJson(m_Minimum_software_release);
    }
    if(m_LogoIsSet)
    {
        val[utility::conversions::to_string_t(U("logo"))] = ModelBase::toJson(m_Logo);
    }

    return val;
}

bool ProductDto::fromJson(const web::json::value& val)
{
    bool ok = true;
    
    if(val.has_field(utility::conversions::to_string_t(U("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("id")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("description"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("description")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setDescription;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
            setDescription(refVal_setDescription);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("short_description"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("short_description")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setShortDescription;
            ok &= ModelBase::fromJson(fieldValue, refVal_setShortDescription);
            setShortDescription(refVal_setShortDescription);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("minimum_software_release_id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("minimum_software_release_id")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setMinimumSoftwareReleaseId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMinimumSoftwareReleaseId);
            setMinimumSoftwareReleaseId(refVal_setMinimumSoftwareReleaseId);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("software_release"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("software_release")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<SoftwareReleaseLimitationDto>> refVal_setSoftwareRelease;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSoftwareRelease);
            setSoftwareRelease(refVal_setSoftwareRelease);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("is_goodwill_visible"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("is_goodwill_visible")));
        if(!fieldValue.is_null())
        {
            bool refVal_setIsGoodwillVisible;
            ok &= ModelBase::fromJson(fieldValue, refVal_setIsGoodwillVisible);
            setIsGoodwillVisible(refVal_setIsGoodwillVisible);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("is_upgrade_compliance_visible"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("is_upgrade_compliance_visible")));
        if(!fieldValue.is_null())
        {
            bool refVal_setIsUpgradeComplianceVisible;
            ok &= ModelBase::fromJson(fieldValue, refVal_setIsUpgradeComplianceVisible);
            setIsUpgradeComplianceVisible(refVal_setIsUpgradeComplianceVisible);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("is_group_compliance_visible"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("is_group_compliance_visible")));
        if(!fieldValue.is_null())
        {
            bool refVal_setIsGroupComplianceVisible;
            ok &= ModelBase::fromJson(fieldValue, refVal_setIsGroupComplianceVisible);
            setIsGroupComplianceVisible(refVal_setIsGroupComplianceVisible);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("is_temporary_license_rules_visible"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("is_temporary_license_rules_visible")));
        if(!fieldValue.is_null())
        {
            bool refVal_setIsTemporaryLicenseRulesVisible;
            ok &= ModelBase::fromJson(fieldValue, refVal_setIsTemporaryLicenseRulesVisible);
            setIsTemporaryLicenseRulesVisible(refVal_setIsTemporaryLicenseRulesVisible);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("prioritized_key"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("prioritized_key")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<PrioritizedKeyMode> refVal_setPrioritizedKey;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPrioritizedKey);
            setPrioritizedKey(refVal_setPrioritizedKey);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("offline_licensing"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("offline_licensing")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<OfflineLicensing> refVal_setOfflineLicensing;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOfflineLicensing);
            setOfflineLicensing(refVal_setOfflineLicensing);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("license_file_name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("license_file_name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setLicenseFileName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLicenseFileName);
            setLicenseFileName(refVal_setLicenseFileName);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("user_id_type"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("user_id_type")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<UserIdType> refVal_setUserIdType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setUserIdType);
            setUserIdType(refVal_setUserIdType);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("client_id_mode"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("client_id_mode")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ClientIdMode> refVal_setClientIdMode;
            ok &= ModelBase::fromJson(fieldValue, refVal_setClientIdMode);
            setClientIdMode(refVal_setClientIdMode);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("maximum_inactive_days"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("maximum_inactive_days")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMaximumInactiveDays;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaximumInactiveDays);
            setMaximumInactiveDays(refVal_setMaximumInactiveDays);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("max_licenses_per_user"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("max_licenses_per_user")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMaxLicensesPerUser;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaxLicensesPerUser);
            setMaxLicensesPerUser(refVal_setMaxLicensesPerUser);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("created_date_utc"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("created_date_utc")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setCreatedDateUtc;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCreatedDateUtc);
            setCreatedDateUtc(refVal_setCreatedDateUtc);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("modified_date_utc"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("modified_date_utc")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setModifiedDateUtc;
            ok &= ModelBase::fromJson(fieldValue, refVal_setModifiedDateUtc);
            setModifiedDateUtc(refVal_setModifiedDateUtc);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("last_modified_by"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("last_modified_by")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setLastModifiedBy;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLastModifiedBy);
            setLastModifiedBy(refVal_setLastModifiedBy);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("minimum_software_release"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("minimum_software_release")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<SoftwareReleaseLimitationDto> refVal_setMinimumSoftwareRelease;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMinimumSoftwareRelease);
            setMinimumSoftwareRelease(refVal_setMinimumSoftwareRelease);
        }
    }
    if(val.has_field(utility::conversions::to_string_t(U("logo"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(U("logo")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ResourceDto> refVal_setLogo;
            ok &= ModelBase::fromJson(fieldValue, refVal_setLogo);
            setLogo(refVal_setLogo);
        }
    }
    return ok;
}

void ProductDto::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("id")), m_Id));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("name")), m_Name));
    }
    if(m_DescriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("description")), m_Description));
    }
    if(m_Short_descriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("short_description")), m_Short_description));
    }
    if(m_Minimum_software_release_idIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("minimum_software_release_id")), m_Minimum_software_release_id));
    }
    if(m_Software_releaseIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("software_release")), m_Software_release));
    }
    if(m_Is_goodwill_visibleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("is_goodwill_visible")), m_Is_goodwill_visible));
    }
    if(m_Is_upgrade_compliance_visibleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("is_upgrade_compliance_visible")), m_Is_upgrade_compliance_visible));
    }
    if(m_Is_group_compliance_visibleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("is_group_compliance_visible")), m_Is_group_compliance_visible));
    }
    if(m_Is_temporary_license_rules_visibleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("is_temporary_license_rules_visible")), m_Is_temporary_license_rules_visible));
    }
    if(m_Prioritized_keyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("prioritized_key")), m_Prioritized_key));
    }
    if(m_Offline_licensingIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("offline_licensing")), m_Offline_licensing));
    }
    if(m_License_file_nameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("license_file_name")), m_License_file_name));
    }
    if(m_User_id_typeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("user_id_type")), m_User_id_type));
    }
    if(m_Client_id_modeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("client_id_mode")), m_Client_id_mode));
    }
    if(m_Maximum_inactive_daysIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("maximum_inactive_days")), m_Maximum_inactive_days));
    }
    if(m_Max_licenses_per_userIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("max_licenses_per_user")), m_Max_licenses_per_user));
    }
    if(m_Created_date_utcIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("created_date_utc")), m_Created_date_utc));
    }
    if(m_Modified_date_utcIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("modified_date_utc")), m_Modified_date_utc));
    }
    if(m_Last_modified_byIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("last_modified_by")), m_Last_modified_by));
    }
    if(m_Minimum_software_releaseIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("minimum_software_release")), m_Minimum_software_release));
    }
    if(m_LogoIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(U("logo")), m_Logo));
    }
}

bool ProductDto::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(U(".")))
    {
        namePrefix += utility::conversions::to_string_t(U("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(U("id"))))
    {
        utility::string_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("description"))))
    {
        utility::string_t refVal_setDescription;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("description"))), refVal_setDescription );
        setDescription(refVal_setDescription);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("short_description"))))
    {
        utility::string_t refVal_setShortDescription;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("short_description"))), refVal_setShortDescription );
        setShortDescription(refVal_setShortDescription);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("minimum_software_release_id"))))
    {
        utility::string_t refVal_setMinimumSoftwareReleaseId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("minimum_software_release_id"))), refVal_setMinimumSoftwareReleaseId );
        setMinimumSoftwareReleaseId(refVal_setMinimumSoftwareReleaseId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("software_release"))))
    {
        std::vector<std::shared_ptr<SoftwareReleaseLimitationDto>> refVal_setSoftwareRelease;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("software_release"))), refVal_setSoftwareRelease );
        setSoftwareRelease(refVal_setSoftwareRelease);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("is_goodwill_visible"))))
    {
        bool refVal_setIsGoodwillVisible;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("is_goodwill_visible"))), refVal_setIsGoodwillVisible );
        setIsGoodwillVisible(refVal_setIsGoodwillVisible);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("is_upgrade_compliance_visible"))))
    {
        bool refVal_setIsUpgradeComplianceVisible;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("is_upgrade_compliance_visible"))), refVal_setIsUpgradeComplianceVisible );
        setIsUpgradeComplianceVisible(refVal_setIsUpgradeComplianceVisible);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("is_group_compliance_visible"))))
    {
        bool refVal_setIsGroupComplianceVisible;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("is_group_compliance_visible"))), refVal_setIsGroupComplianceVisible );
        setIsGroupComplianceVisible(refVal_setIsGroupComplianceVisible);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("is_temporary_license_rules_visible"))))
    {
        bool refVal_setIsTemporaryLicenseRulesVisible;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("is_temporary_license_rules_visible"))), refVal_setIsTemporaryLicenseRulesVisible );
        setIsTemporaryLicenseRulesVisible(refVal_setIsTemporaryLicenseRulesVisible);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("prioritized_key"))))
    {
        std::shared_ptr<PrioritizedKeyMode> refVal_setPrioritizedKey;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("prioritized_key"))), refVal_setPrioritizedKey );
        setPrioritizedKey(refVal_setPrioritizedKey);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("offline_licensing"))))
    {
        std::shared_ptr<OfflineLicensing> refVal_setOfflineLicensing;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("offline_licensing"))), refVal_setOfflineLicensing );
        setOfflineLicensing(refVal_setOfflineLicensing);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("license_file_name"))))
    {
        utility::string_t refVal_setLicenseFileName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("license_file_name"))), refVal_setLicenseFileName );
        setLicenseFileName(refVal_setLicenseFileName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("user_id_type"))))
    {
        std::shared_ptr<UserIdType> refVal_setUserIdType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("user_id_type"))), refVal_setUserIdType );
        setUserIdType(refVal_setUserIdType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("client_id_mode"))))
    {
        std::shared_ptr<ClientIdMode> refVal_setClientIdMode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("client_id_mode"))), refVal_setClientIdMode );
        setClientIdMode(refVal_setClientIdMode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("maximum_inactive_days"))))
    {
        int32_t refVal_setMaximumInactiveDays;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("maximum_inactive_days"))), refVal_setMaximumInactiveDays );
        setMaximumInactiveDays(refVal_setMaximumInactiveDays);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("max_licenses_per_user"))))
    {
        int32_t refVal_setMaxLicensesPerUser;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("max_licenses_per_user"))), refVal_setMaxLicensesPerUser );
        setMaxLicensesPerUser(refVal_setMaxLicensesPerUser);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("created_date_utc"))))
    {
        utility::datetime refVal_setCreatedDateUtc;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("created_date_utc"))), refVal_setCreatedDateUtc );
        setCreatedDateUtc(refVal_setCreatedDateUtc);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("modified_date_utc"))))
    {
        utility::datetime refVal_setModifiedDateUtc;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("modified_date_utc"))), refVal_setModifiedDateUtc );
        setModifiedDateUtc(refVal_setModifiedDateUtc);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("last_modified_by"))))
    {
        utility::string_t refVal_setLastModifiedBy;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("last_modified_by"))), refVal_setLastModifiedBy );
        setLastModifiedBy(refVal_setLastModifiedBy);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("minimum_software_release"))))
    {
        std::shared_ptr<SoftwareReleaseLimitationDto> refVal_setMinimumSoftwareRelease;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("minimum_software_release"))), refVal_setMinimumSoftwareRelease );
        setMinimumSoftwareRelease(refVal_setMinimumSoftwareRelease);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(U("logo"))))
    {
        std::shared_ptr<ResourceDto> refVal_setLogo;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(U("logo"))), refVal_setLogo );
        setLogo(refVal_setLogo);
    }
    return ok;
}

utility::string_t ProductDto::getId() const
{
    return m_Id;
}

void ProductDto::setId(const utility::string_t& value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool ProductDto::idIsSet() const
{
    return m_IdIsSet;
}

void ProductDto::unsetId()
{
    m_IdIsSet = false;
}
utility::string_t ProductDto::getName() const
{
    return m_Name;
}

void ProductDto::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool ProductDto::nameIsSet() const
{
    return m_NameIsSet;
}

void ProductDto::unsetName()
{
    m_NameIsSet = false;
}
utility::string_t ProductDto::getDescription() const
{
    return m_Description;
}

void ProductDto::setDescription(const utility::string_t& value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}

bool ProductDto::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}

void ProductDto::unsetDescription()
{
    m_DescriptionIsSet = false;
}
utility::string_t ProductDto::getShortDescription() const
{
    return m_Short_description;
}

void ProductDto::setShortDescription(const utility::string_t& value)
{
    m_Short_description = value;
    m_Short_descriptionIsSet = true;
}

bool ProductDto::shortDescriptionIsSet() const
{
    return m_Short_descriptionIsSet;
}

void ProductDto::unsetShort_description()
{
    m_Short_descriptionIsSet = false;
}
utility::string_t ProductDto::getMinimumSoftwareReleaseId() const
{
    return m_Minimum_software_release_id;
}

void ProductDto::setMinimumSoftwareReleaseId(const utility::string_t& value)
{
    m_Minimum_software_release_id = value;
    m_Minimum_software_release_idIsSet = true;
}

bool ProductDto::minimumSoftwareReleaseIdIsSet() const
{
    return m_Minimum_software_release_idIsSet;
}

void ProductDto::unsetMinimum_software_release_id()
{
    m_Minimum_software_release_idIsSet = false;
}
std::vector<std::shared_ptr<SoftwareReleaseLimitationDto>>& ProductDto::getSoftwareRelease()
{
    return m_Software_release;
}

void ProductDto::setSoftwareRelease(const std::vector<std::shared_ptr<SoftwareReleaseLimitationDto>>& value)
{
    m_Software_release = value;
    m_Software_releaseIsSet = true;
}

bool ProductDto::softwareReleaseIsSet() const
{
    return m_Software_releaseIsSet;
}

void ProductDto::unsetSoftware_release()
{
    m_Software_releaseIsSet = false;
}
bool ProductDto::isIsGoodwillVisible() const
{
    return m_Is_goodwill_visible;
}

void ProductDto::setIsGoodwillVisible(bool value)
{
    m_Is_goodwill_visible = value;
    m_Is_goodwill_visibleIsSet = true;
}

bool ProductDto::isGoodwillVisibleIsSet() const
{
    return m_Is_goodwill_visibleIsSet;
}

void ProductDto::unsetIs_goodwill_visible()
{
    m_Is_goodwill_visibleIsSet = false;
}
bool ProductDto::isIsUpgradeComplianceVisible() const
{
    return m_Is_upgrade_compliance_visible;
}

void ProductDto::setIsUpgradeComplianceVisible(bool value)
{
    m_Is_upgrade_compliance_visible = value;
    m_Is_upgrade_compliance_visibleIsSet = true;
}

bool ProductDto::isUpgradeComplianceVisibleIsSet() const
{
    return m_Is_upgrade_compliance_visibleIsSet;
}

void ProductDto::unsetIs_upgrade_compliance_visible()
{
    m_Is_upgrade_compliance_visibleIsSet = false;
}
bool ProductDto::isIsGroupComplianceVisible() const
{
    return m_Is_group_compliance_visible;
}

void ProductDto::setIsGroupComplianceVisible(bool value)
{
    m_Is_group_compliance_visible = value;
    m_Is_group_compliance_visibleIsSet = true;
}

bool ProductDto::isGroupComplianceVisibleIsSet() const
{
    return m_Is_group_compliance_visibleIsSet;
}

void ProductDto::unsetIs_group_compliance_visible()
{
    m_Is_group_compliance_visibleIsSet = false;
}
bool ProductDto::isIsTemporaryLicenseRulesVisible() const
{
    return m_Is_temporary_license_rules_visible;
}

void ProductDto::setIsTemporaryLicenseRulesVisible(bool value)
{
    m_Is_temporary_license_rules_visible = value;
    m_Is_temporary_license_rules_visibleIsSet = true;
}

bool ProductDto::isTemporaryLicenseRulesVisibleIsSet() const
{
    return m_Is_temporary_license_rules_visibleIsSet;
}

void ProductDto::unsetIs_temporary_license_rules_visible()
{
    m_Is_temporary_license_rules_visibleIsSet = false;
}
std::shared_ptr<PrioritizedKeyMode> ProductDto::getPrioritizedKey() const
{
    return m_Prioritized_key;
}

void ProductDto::setPrioritizedKey(const std::shared_ptr<PrioritizedKeyMode>& value)
{
    m_Prioritized_key = value;
    m_Prioritized_keyIsSet = true;
}

bool ProductDto::prioritizedKeyIsSet() const
{
    return m_Prioritized_keyIsSet;
}

void ProductDto::unsetPrioritized_key()
{
    m_Prioritized_keyIsSet = false;
}
std::shared_ptr<OfflineLicensing> ProductDto::getOfflineLicensing() const
{
    return m_Offline_licensing;
}

void ProductDto::setOfflineLicensing(const std::shared_ptr<OfflineLicensing>& value)
{
    m_Offline_licensing = value;
    m_Offline_licensingIsSet = true;
}

bool ProductDto::offlineLicensingIsSet() const
{
    return m_Offline_licensingIsSet;
}

void ProductDto::unsetOffline_licensing()
{
    m_Offline_licensingIsSet = false;
}
utility::string_t ProductDto::getLicenseFileName() const
{
    return m_License_file_name;
}

void ProductDto::setLicenseFileName(const utility::string_t& value)
{
    m_License_file_name = value;
    m_License_file_nameIsSet = true;
}

bool ProductDto::licenseFileNameIsSet() const
{
    return m_License_file_nameIsSet;
}

void ProductDto::unsetLicense_file_name()
{
    m_License_file_nameIsSet = false;
}
std::shared_ptr<UserIdType> ProductDto::getUserIdType() const
{
    return m_User_id_type;
}

void ProductDto::setUserIdType(const std::shared_ptr<UserIdType>& value)
{
    m_User_id_type = value;
    m_User_id_typeIsSet = true;
}

bool ProductDto::userIdTypeIsSet() const
{
    return m_User_id_typeIsSet;
}

void ProductDto::unsetUser_id_type()
{
    m_User_id_typeIsSet = false;
}
std::shared_ptr<ClientIdMode> ProductDto::getClientIdMode() const
{
    return m_Client_id_mode;
}

void ProductDto::setClientIdMode(const std::shared_ptr<ClientIdMode>& value)
{
    m_Client_id_mode = value;
    m_Client_id_modeIsSet = true;
}

bool ProductDto::clientIdModeIsSet() const
{
    return m_Client_id_modeIsSet;
}

void ProductDto::unsetClient_id_mode()
{
    m_Client_id_modeIsSet = false;
}
int32_t ProductDto::getMaximumInactiveDays() const
{
    return m_Maximum_inactive_days;
}

void ProductDto::setMaximumInactiveDays(int32_t value)
{
    m_Maximum_inactive_days = value;
    m_Maximum_inactive_daysIsSet = true;
}

bool ProductDto::maximumInactiveDaysIsSet() const
{
    return m_Maximum_inactive_daysIsSet;
}

void ProductDto::unsetMaximum_inactive_days()
{
    m_Maximum_inactive_daysIsSet = false;
}
int32_t ProductDto::getMaxLicensesPerUser() const
{
    return m_Max_licenses_per_user;
}

void ProductDto::setMaxLicensesPerUser(int32_t value)
{
    m_Max_licenses_per_user = value;
    m_Max_licenses_per_userIsSet = true;
}

bool ProductDto::maxLicensesPerUserIsSet() const
{
    return m_Max_licenses_per_userIsSet;
}

void ProductDto::unsetMax_licenses_per_user()
{
    m_Max_licenses_per_userIsSet = false;
}
utility::datetime ProductDto::getCreatedDateUtc() const
{
    return m_Created_date_utc;
}

void ProductDto::setCreatedDateUtc(const utility::datetime& value)
{
    m_Created_date_utc = value;
    m_Created_date_utcIsSet = true;
}

bool ProductDto::createdDateUtcIsSet() const
{
    return m_Created_date_utcIsSet;
}

void ProductDto::unsetCreated_date_utc()
{
    m_Created_date_utcIsSet = false;
}
utility::datetime ProductDto::getModifiedDateUtc() const
{
    return m_Modified_date_utc;
}

void ProductDto::setModifiedDateUtc(const utility::datetime& value)
{
    m_Modified_date_utc = value;
    m_Modified_date_utcIsSet = true;
}

bool ProductDto::modifiedDateUtcIsSet() const
{
    return m_Modified_date_utcIsSet;
}

void ProductDto::unsetModified_date_utc()
{
    m_Modified_date_utcIsSet = false;
}
utility::string_t ProductDto::getLastModifiedBy() const
{
    return m_Last_modified_by;
}

void ProductDto::setLastModifiedBy(const utility::string_t& value)
{
    m_Last_modified_by = value;
    m_Last_modified_byIsSet = true;
}

bool ProductDto::lastModifiedByIsSet() const
{
    return m_Last_modified_byIsSet;
}

void ProductDto::unsetLast_modified_by()
{
    m_Last_modified_byIsSet = false;
}
std::shared_ptr<SoftwareReleaseLimitationDto> ProductDto::getMinimumSoftwareRelease() const
{
    return m_Minimum_software_release;
}

void ProductDto::setMinimumSoftwareRelease(const std::shared_ptr<SoftwareReleaseLimitationDto>& value)
{
    m_Minimum_software_release = value;
    m_Minimum_software_releaseIsSet = true;
}

bool ProductDto::minimumSoftwareReleaseIsSet() const
{
    return m_Minimum_software_releaseIsSet;
}

void ProductDto::unsetMinimum_software_release()
{
    m_Minimum_software_releaseIsSet = false;
}
std::shared_ptr<ResourceDto> ProductDto::getLogo() const
{
    return m_Logo;
}

void ProductDto::setLogo(const std::shared_ptr<ResourceDto>& value)
{
    m_Logo = value;
    m_LogoIsSet = true;
}

bool ProductDto::logoIsSet() const
{
    return m_LogoIsSet;
}

void ProductDto::unsetLogo()
{
    m_LogoIsSet = false;
}
}
}
}
}


